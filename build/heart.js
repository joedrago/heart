// Generated by CoffeeScript 2.4.1
(function() {
  var Discord, discordClient, discordConfig, discordGuild, discordID, fatalError, findRole, findUser, fs, main, onInputEvent, onTick, readline, roleAdd, roleAllowed, roleDel, roleList, send;

  fs = require('fs');

  Discord = require('discord.js');

  readline = require('readline');

  discordID = null;

  discordConfig = null;

  discordClient = null;

  discordGuild = null;

  roleAllowed = {};

  fatalError = function(reason) {
    console.error(`FATAL [heart]: ${reason}`);
    return process.exit(1);
  };

  send = function(channelName, text) {
    var channel;
    channel = discordClient.channels.cache.find(function(c) {
      return (c.name === channelName) && (c.type === 'text');
    });
    if (channel != null) {
      channel.send(text);
    }
  };

  findRole = function(user, roleName, chan) {
    var role;
    if (!roleAllowed[roleName]) {
      send(chan, `ERROR: Role \`${roleName}\` is unavailable to be modified this way.`);
      return null;
    }
    role = discordGuild.roles.cache.find(function(e) {
      return e.name === roleName;
    });
    if (role == null) {
      send(chan, `ERROR: Can't find role \`${roleName}\` on the server.`);
    }
    return role;
  };

  findUser = function(username, chan) {
    var user;
    user = discordGuild.members.cache.find(function(e) {
      console.log(`looking at ${JSON.stringify(e)}`);
      return e.displayName === username;
    });
    if (user == null) {
      send(chan, `ERROR: Can't find user \`${username}\` on the server.`);
    }
    return user;
  };

  roleAdd = function(username, roleName, chan) {
    var role, user;
    role = findRole(user, roleName, chan);
    if (role == null) {
      return;
    }
    user = findUser(username, chan);
    if (user == null) {
      return;
    }
    return user.roles.add(role).then(function() {
      return send(chan, `Added role \`${roleName}\` to user \`${username}\`.`);
    }).catch(function(err) {
      return send(chan, `ERROR: Failed to add role \`${roleName}\` to user \`${username}\`: ${err}`);
    });
  };

  roleDel = function(username, roleName, chan) {
    var role, user;
    role = findRole(user, roleName, chan);
    if (role == null) {
      return;
    }
    user = findUser(username, chan);
    if (user == null) {
      return;
    }
    return user.roles.remove(role).then(function() {
      return send(chan, `Removed role \`${roleName}\` from user \`${username}\`.`);
    }).catch(function(err) {
      return send(chan, `ERROR: Failed to remove role \`${roleName}\` from user \`${username}\`: ${err}`);
    });
  };

  roleList = function(chan) {
    var list;
    list = discordConfig.roles.map(function(role) {
      return `\`${role}\``;
    }).join(", ");
    return send(chan, `Roles: ${list}`);
  };

  onTick = function() {
    var ev;
    ev = {
      type: 'tick'
    };
    return console.log(JSON.stringify(ev));
  };

  onInputEvent = function(ev) {
    var delay;
    switch (ev.type) {
      case 'msg':
        if ((ev.chan != null) && (ev.text != null) && (ev.delay != null)) {
          delay = parseInt(ev.delay);
          setTimeout(function() {
            return send(ev.chan, ev.text);
          }, delay);
        }
        break;
      case 'radd':
        if ((ev.user != null) && (ev.role != null) && (ev.chan != null)) {
          roleAdd(ev.user, ev.role, ev.chan);
        }
        break;
      case 'rdel':
        if ((ev.user != null) && (ev.role != null) && (ev.chan != null)) {
          roleDel(ev.user, ev.role, ev.chan);
        }
        break;
      case 'rlist':
        if (ev.chan != null) {
          roleList(ev.chan);
        }
        break;
      default:
        console.error(`Unknown event type: ${ev.type}`);
    }
  };

  main = function() {
    var i, len, ref, rl, role;
    if (!fs.existsSync("heart.json")) {
      fatalError("Can't find heart.json");
    }
    discordConfig = JSON.parse(fs.readFileSync("heart.json", "utf8"));
    ref = discordConfig.roles;
    for (i = 0, len = ref.length; i < len; i++) {
      role = ref[i];
      roleAllowed[role] = true;
    }
    discordClient = new Discord.Client();
    discordClient.on('ready', function() {
      console.log(JSON.stringify({
        type: 'login',
        tag: discordClient.user.tag
      }));
      return discordClient.guilds.fetch(discordConfig.guild).then(function(guild) {
        return discordGuild = guild;
      });
    });
    discordClient.on('message', function(msg) {
      if (discordGuild === null) {
        return;
      }
      return discordGuild.members.fetch(msg).then(function(user) {
        var ev;
        if (user.id === discordClient.user.id) {
          return;
        }
        // Don't respond to yourself
        ev = {
          type: 'msg',
          chan: msg.channel.name,
          user: user.displayName,
          text: msg.content
        };
        return console.log(JSON.stringify(ev));
      });
    });
    setInterval(onTick, 60 * 1000);
    rl = readline.createInterface({
      input: process.stdin,
      output: process.stderr
    });
    rl.on('line', function(rawJSON) {
      var ev;
      ev = null;
      try {
        ev = JSON.parse(rawJSON);
      } catch (error) {
        console.error(`Ignoring invalid JSON: ${rawJSON}`);
        return;
      }
      return onInputEvent(ev);
    });
    return discordClient.login(discordConfig.secrets.discord);
  };

  module.exports = main;

}).call(this);
